<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ¼ãƒãƒ£ãƒ«ãƒ»ã‚¤ã‚·ãƒ¥ãƒ¼ï¼ˆæ•™è‚²ï¼‰ãƒªãƒ³ã‚¯é›†</title>
<style>
  :root{--gap:14px}
  body{font-family:system-ui,"Noto Sans JP",sans-serif;margin:24px}
  header{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin-bottom:var(--gap)}
  input,select,button{padding:.6rem .7rem;font-size:16px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:var(--gap)}
  .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px}
  .muted{color:#6b7280;font-size:0.9em}
  .warn{color:#b45309}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .tag{background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:.1rem .6rem;font-size:.85em}
  a{color:#1f6feb;text-decoration:none}
  a:hover{text-decoration:underline}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:.3rem .6rem;display:inline-block}
  .right{margin-left:auto}
  .btn{cursor:pointer;background:#fff}
  .dead{pointer-events:none;color:#94a3b8;text-decoration:none}
  #dbgBtn{position:fixed;right:12px;top:10px}
  #dbg{position:fixed;right:12px;top:48px;width:min(520px,90vw);height:40vh;overflow:auto;background:#0b1020;color:#d1d5db;border:1px solid #1f2937;border-radius:12px;padding:10px;display:none;white-space:pre-wrap;font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  #upload{display:none;gap:8px;align-items:center;margin-top:8px}
</style>
</head>
<body>
<header>
  <input id="q" placeholder="ã‚¿ã‚¤ãƒˆãƒ« / è‘—è€… / èªŒå / URL / ã‚¿ã‚°ã§æ¤œç´¢" oninput="render()" />
  <select id="sort" onchange="render()">
    <option value="year-desc">æ–°ã—ã„é †</option>
    <option value="year-asc">å¤ã„é †</option>
    <option value="title-asc">ã‚¿ã‚¤ãƒˆãƒ«Aâ†’Z</option>
    <option value="title-desc">ã‚¿ã‚¤ãƒˆãƒ«Zâ†’A</option>
  </select>
  <label class="pill"><input id="eduOnly" type="checkbox" onchange="render()"> æ•™è‚²ã®ã¿</label>
  <span id="count" class="pill"></span>
  <span class="right muted">CSVã¯ <code>items.csv</code>ï¼ˆid,url,type,tags,notesï¼‰</span>
</header>

<button id="dbgBtn" class="pill btn" onclick="toggleDbg()">ğŸ§ªãƒ‡ãƒãƒƒã‚°</button>
<pre id="dbg"></pre>

<div id="upload" class="pill">
  <span>CSVãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã¶ã¨ãã®å ´ã§è¡¨ç¤ºãƒ†ã‚¹ãƒˆãŒã§ãã¾ã™ â†’</span>
  <input type="file" id="file" accept=".csv,text/csv" />
  <button class="pill btn" onclick="loadSample()">ã‚µãƒ³ãƒ—ãƒ«æŒ¿å…¥</button>
</div>

<div id="list" class="grid" style="margin-top:8px">
  <div class="muted">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
</div>

<script>
/* ===== è¨­å®š ===== */
const REPO_HOST = 'hokuriku.repo.nii.ac.jp'; // ä»–ãƒªãƒã‚¸ãƒˆãƒªãªã‚‰å¤‰æ›´
const EDU_SET_PREFIX = '29';
const DATA_SRC = (()=>{ const u=new URL('items.csv', location.href); u.searchParams.set('t', Date.now()); return u.href; })();

/* ===== ãƒ‡ãƒãƒƒã‚° ===== */
const $dbg = ()=>document.getElementById('dbg');
function log(...args){ console.log(...args); try{ $dbg().textContent += args.map(a=>typeof a==='string'?a:JSON.stringify(a)).join(' ')+'\n'; }catch{} }
function toggleDbg(){ const el=$dbg(); el.style.display = el.style.display==='none'?'block':'none'; }
window.addEventListener('error', e=>{ log('window.onerror:', e.message, '@', e.filename, e.lineno+':'+e.colno); });
window.addEventListener('unhandledrejection', e=>{ log('unhandledrejection:', String(e.reason||e)); });

/* ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */
const norm = s => (s||'').toString().toLowerCase();
const escapeHtml = s => (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
const isHttp = s => /^https?:\/\//i.test(s||'');
const isDOI  = s => /^10\.\S+\/\S+$/i.test((s||'').trim());
const isWekoUrl = u => /\/records?\/\d+/.test(u||'');

function splitCsvLine(line){
  const re=/("([^"]|"")*"|[^,]+)/g; const out=[]; let m;
  while((m=re.exec(line))!==null) out.push(m[0].replace(/^"(.*)"$/,'$1').replace(/""/g,'"'));
  return out.map(s=>s.trim());
}

async function fetchCsv(url){
  log('fetchCsv:', url);
  const res = await fetch(url, {cache:'no-store'}).catch(err=>{ log('fetchCsv error:', err); throw err; });
  log('fetchCsv status:', res.status, res.statusText);
  if(!res.ok) throw new Error('CSV not found: '+res.status);
  const text = await res.text();
  // UTF-16 ã®å ´åˆã«æ–‡å­—åŒ–ã‘ã§ç©ºé…åˆ—ã«ãªã‚‹ã®ã‚’é˜²ããŸã‚ BOM ã‚’å¹…åºƒãå‰¥ãŒã™
  const t = text.replace(/^\uFEFF|\u0000/g,'');
  const lines = t.trim().split(/\r?\n/);
  if(!lines.length) return [];
  const header = splitCsvLine(lines.shift()).map(s=>s.replace(/^\uFEFF/,'').trim().toLowerCase());
  log('CSV header:', header.join(','));
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const rows = lines.filter(Boolean).map(line=>{
    const c=splitCsvLine(line);
    return {
      id:   (c[idx['id']]   ?? '').trim(),
      url:  (c[idx['url']]  ?? '').trim(),
      type: (c[idx['type']] ?? '').trim().toLowerCase(),
      tags: (c[idx['tags']] ?? '').trim(),
      notes:(c[idx['notes']]?? '').trim()
    };
  }).filter(r=>r.id || r.url || r.type);
  log('CSV rows:', rows.length);
  return rows;
}

/* ===== WEKO URL æ­£è¦åŒ– ===== */
function normalizeWekoUrl(id, url){
  if (isHttp(url) && isWekoUrl(url)) return url;
  const idFromUrl = (()=> {
    if (/^\d+$/.test(url)) return url;
    const m = /\/records?\/(\d+)/.exec(url||'');
    if (m) return m[1];
    if (/^records?\/(\d+)/.test(url||'')) return RegExp.$1;
    return '';
  })();
  const recid = idFromUrl || (/^\d+$/.test(id||'') ? id : '');
  return recid ? `https://${REPO_HOST}/records/${recid}` : '';
}

/* ===== ãƒ¡ã‚¿å–å¾—ï¼šDOI ===== */
async function fetchMetaDOI(doi){
  const steps = [
    ['crossref','https://api.crossref.org/works/'+encodeURIComponent(doi), {'Accept':'application/json'}, j=>({title:j.message?.title?.[0]||'',year:j.message?.issued?.['date-parts']?.[0]?.[0]||j.message?.created?.['date-parts']?.[0]?.[0]||'',authors:(j.message?.author||[]).map(a=>[a.given,a.family].filter(Boolean).join(' ')).join(', '),journal:j.message?.['container-title']?.[0]||''})],
    ['doi.org-csl','https://doi.org/'+encodeURIComponent(doi), {'Accept':'application/vnd.citationstyles.csl+json'}, j=>({title:Array.isArray(j.title)?j.title[0]:(j.title||''),year:j.issued?.['date-parts']?.[0]?.[0]||'',authors:(j.author||[]).map(a=>a.family||a.given?[a.given,a.family].filter(Boolean).join(' '):(a.name||'')).join(', '),journal:Array.isArray(j['container-title'])?j['container-title'][0]:(j['container-title']||j['container-title-short']||'')})],
    ['datacite','https://api.datacite.org/dois/'+encodeURIComponent(doi), {'Accept':'application/json'}, j=>{const a=j.data?.attributes||{}; return {title:a.titles?.[0]?.title||'',year:a.publicationYear||'',authors:(a.creators||a.contributors||[]).map(p=>[p.givenName,p.familyName,p.name].filter(Boolean)[0]||'').filter(Boolean).join(', '),journal:(a.container?.title)||a.publisher||''};}],
    ['openalex','https://api.openalex.org/works/https://doi.org/'+encodeURIComponent(doi), {'Accept':'application/json'}, j=>({title:j.title||'',year:j.publication_year||(j.from_publication_date||'').slice(0,4)||'',authors:(j.authorships||[]).map(x=>x.author?.display_name).filter(Boolean).join(', '),journal:j.host_venue?.display_name||j.primary_location?.source?.display_name||''})]
  ];
  for (const [src,u,h,shape] of steps){
    try{ const r=await fetch(u,{headers:h,cache:'no-store'}); log('DOI step',src,'status',r.status); if(r.ok){ const json=await r.json(); return {source:src, meta:shape(json)}; } }catch(e){ log('DOI step error',src,e); }
  }
  return {source:'none', meta:{title:'',year:'',authors:'',journal:''}};
}

/* ===== ãƒ¡ã‚¿å–å¾—ï¼šWEKO ===== */
async function fetchMetaWEKO(absUrl){
  if (!absUrl) return {source:'weko-json-fail', meta:emptyMeta(), edu:false};
  try{
    const u = new URL(absUrl);
    const m = /\/records?\/(\d+)/.exec(u.pathname);
    if (!m) return {source:'weko-json-fail', meta:emptyMeta(), edu:false};
    const jsonUrl = `${u.protocol}//${u.host}/records/${m[1]}/export/json`;
    log('WEKO json:', jsonUrl);
    const res = await fetch(jsonUrl, { cache:'no-store' });
    log('WEKO status:', res.status);
    if (!res.ok) throw new Error('status '+res.status);
    const j = await res.json();
    const md = j.metadata || {};
    const titleCandidates = [
      md.item_title,
      md.item_titles?.attribute_value_mlt?.[0]?.subitem_title,
      Array.isArray(j.title) ? j.title[0] : j.title,
      md.title
    ].filter(Boolean);
    const title = (titleCandidates.find(Boolean) || '').toString();
    let authors = '';
    const creators = md.item_creator?.attribute_value_mlt || md.creators || [];
    const names = [];
    if (Array.isArray(creators)){
      creators.forEach(c=>{
        if (Array.isArray(c.creatorNames)) c.creatorNames.forEach(n=>n?.creatorName && names.push(n.creatorName));
        else if (c.creatorName) names.push(c.creatorName);
        else if (typeof c.name === 'string') names.push(c.name);
      });
    }
    authors = names.filter(Boolean).join(', ');
    const bib = md.item_10002_biblio_info_7?.attribute_value_mlt?.[0] || {};
    const issued = bib.bibliographicIssueDates?.bibliographicIssueDate || md.publish_date || md.pubdate?.attribute_value || '';
    const year = (issued||'').toString().slice(0,4);
    const journal = (bib.bibliographic_titles?.[0]?.bibliographic_title) || '';
    const sets = md._oai?.sets || j.metadata?._oai?.sets || [];
    const eduHit = Array.isArray(sets) && sets.some(s => (s||'').startsWith(EDU_SET_PREFIX));
    return { source:'weko-json', meta:{ title, authors, year, journal }, edu:eduHit };
  }catch(e){
    log('WEKO fetch error:', String(e));
    return { source:'weko-json-fail', meta:emptyMeta(), edu:false };
  }
}

function emptyMeta(){ return { title:'', authors:'', year:'', journal:'' }; }

/* ===== è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ ===== */
function passFilter(item, q, eduOnly){
  if (eduOnly && !item.edu) return false;
  if (!q) return true;
  return [item.meta.title, item.meta.authors, item.meta.journal, item.display, item.tags, item.notes]
    .some(v => norm(v).includes(q));
}
function sortBy(items, mode){
  const byYear=(a,b)=>(b.meta.year||0)-(a.meta.year||0);
  const byTitle=(a,b)=>(a.meta.title||'').localeCompare(b.meta.title||'');
  if (mode==='year-asc') return items.sort((a,b)=>-byYear(a,b));
  if (mode==='title-asc') return items.sort(byTitle);
  if (mode==='title-desc') return items.sort((a,b)=>-byTitle(a,b));
  return items.sort(byYear);
}

let records=[];

/* ===== ãƒ“ãƒ«ãƒ‰ ===== */
async function buildItem(row){
  const guessed = isDOI(row.id)||isDOI(row.url) ? 'doi'
                 : (isWekoUrl(row.url)||row.type==='weko') ? 'weko'
                 : (row.type||'url');
  const type = (row.type||guessed||'').toLowerCase();
  const out = { type, rawId: row.id||'', rawUrl: row.url||'', tags: row.tags||'', notes: row.notes||'', edu:false, meta:emptyMeta(), source:'none' };

  if (type==='doi'){
    const doi = isDOI(row.id) ? row.id : (row.url||'').replace(/^https?:\/\/doi\.org\//i,'');
    const m = await fetchMetaDOI(doi);
    out.meta = m.meta; out.source = m.source; out.display = doi; out.link = 'https://doi.org/'+encodeURIComponent(doi);
  }else if (type==='weko'){
    const absUrl = normalizeWekoUrl(row.id, row.url);
    log('normalizeWekoUrl:', row.id, row.url, '=>', absUrl||'(empty)');
    out.display = absUrl || (row.url || row.id || '(ãƒªãƒ³ã‚¯ä¸æ˜)');
    out.link = absUrl || '';
    const m = await fetchMetaWEKO(absUrl);
    out.meta = m.meta; out.source = m.source; out.edu = !!m.edu;
  }else{
    const link = isHttp(row.url) ? row.url : '';
    out.display = link || (row.url || row.id || '(ãƒªãƒ³ã‚¯ä¸æ˜)');
    out.link = link;
  }
  return out;
}

async function boot(){
  const start = Date.now();
  const timeout = setTimeout(()=>{
    const tips = `âš ï¸ èª­ã¿è¾¼ã¿ãŒé•·å¼•ã„ã¦ã„ã¾ã™ã€‚
- items.csv ãŒå­˜åœ¨ã—ãªã„ / å ´æ‰€ãŒé•ã†ï¼ˆã“ã®URLã§é–‹ã‘ã‚‹ã‹ç¢ºèªï¼‰
- GitHub Pages ã®å…¬é–‹ãƒ–ãƒ©ãƒ³ãƒ/ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šãŒ index.html ã¨ä¸€è‡´ã—ã¦ã„ãªã„
- CSV ãŒ UTF-16 ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ï¼ˆUTF-8 ã§ä¿å­˜ã—ç›´ã™ï¼‰
- ãƒ–ãƒ©ã‚¦ã‚¶æ‹¡å¼µæ©Ÿèƒ½ã«ã‚ˆã‚‹ãƒ–ãƒ­ãƒƒã‚¯
`;
    document.getElementById('list').innerHTML = `<div class="muted">${tips.replace(/\n/g,'<br>')}</div>`;
  }, 3000);

  try{
    const rows = await fetchCsv(DATA_SRC);
    clearTimeout(timeout);
    if (!rows.length){
      document.getElementById('list').innerHTML = `<div class="muted">CSVã¯èª­ã¿è¾¼ã‚ã¾ã—ãŸãŒã€è¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>`;
      document.getElementById('upload').style.display = 'flex';
      return;
    }
    const slot=6, tmp=[];
    for (let i=0;i<rows.length;i+=slot){
      const batch = rows.slice(i,i+slot).map(r=>buildItem(r));
      tmp.push(...await Promise.all(batch));
    }
    records = tmp;
    log('records built:', records.length, 'in', (Date.now()-start)+'ms');
    render();
  }catch(e){
    clearTimeout(timeout);
    log('boot error:', e);
    document.getElementById('list').innerHTML = `<div class="muted">èª­è¾¼ã‚¨ãƒ©ãƒ¼: ${escapeHtml(String(e))}</div>`;
    document.getElementById('upload').style.display = 'flex';
  }
}

function render(){
  const q = norm(document.getElementById('q').value);
  const mode = document.getElementById('sort').value;
  const eduOnly = document.getElementById('eduOnly').checked;
  const target = document.getElementById('list');
  const arr = sortBy(records.filter(r=>passFilter(r,q,eduOnly)), mode);

  target.innerHTML = arr.map(r=>{
    const year = r.meta.year ? ` (${r.meta.year})` : '';
    const tags = (r.tags||'').split(';').map(s=>s.trim()).filter(Boolean).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join(' ');
    const notes = r.notes ? `<div class="muted">ğŸ“ ${escapeHtml(r.notes)}</div>`:'';
    const journal = r.meta.journal ? `<span class="muted"> â€” ${escapeHtml(r.meta.journal)}</span>` : '';
    const title = escapeHtml(r.meta.title || r.display);
    const authors = escapeHtml(r.meta.authors || '');
    const src = r.source ? `<span class="pill muted">${r.source}</span>` : '';
    const edu = r.edu ? `<span class="pill">æ•™è‚²</span>` : '';
    const href = r.link || 'javascript:void(0)';
    const cls  = r.link ? '' : 'dead';
    const warn = (!r.link) ? `<span class="pill warn" title="URLã‚’æ­£è¦åŒ–ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚id/urlåˆ—ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚">ãƒªãƒ³ã‚¯ä¸æ˜</span>` : '';
    return `
      <div class="card">
        <div><a class="${cls}" href="${href}" target="${r.link ? '_blank' : ''}" rel="noopener"><strong>${title}</strong></a>${year}${journal} ${warn}</div>
        <div class="muted">${authors}</div>
        <div class="row" style="margin:.4rem 0">${tags} ${edu}</div>
        ${notes}
        <div class="row" style="margin-top:.6rem;align-items:center;gap:8px">
          ${src}
          <code class="pill">${escapeHtml(r.display)}</code>
        </div>
      </div>`;
  }).join('');

  document.getElementById('count').textContent = `${arr.length} ä»¶`;
}

/* ===== ãƒ­ãƒ¼ã‚«ãƒ«CSVã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆå¤±æ•—æ™‚ã®å‹•ä½œç¢ºèªç”¨ï¼‰ ===== */
document.getElementById('file').addEventListener('change', async e=>{
  const f = e.target.files?.[0]; if(!f) return;
  const text = await f.text();
  const blob = new Blob([text], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  try{
    const rows = await fetchCsv(url);
    const slot=6, tmp=[];
    for (let i=0;i<rows.length;i+=slot){
      const batch = rows.slice(i,i+slot).map(r=>buildItem(r));
      tmp.push(...await Promise.all(batch));
    }
    records = tmp; render(); log('loaded via upload:', rows.length);
  }catch(err){
    log('upload parse error:', err);
  }
});

function loadSample(){
  const sample = `id,url,type,tags,notes
2000222,,weko,æ•™è‚²;ç´€è¦,ãƒ†ã‚¹ãƒˆ
578,,weko,æ•™è‚²,JSONç›´å–ã‚Šã®å‹•ä½œç¢ºèª`;
  const blob = new Blob([sample], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  document.getElementById('file').value = '';
  fetchCsv(url).then(async rows=>{
    const slot=6, tmp=[];
    for (let i=0;i<rows.length;i+=slot){
      const batch = rows.slice(i,i+slot).map(r=>buildItem(r));
      tmp.push(...await Promise.all(batch));
    }
    records = tmp; render(); log('sample loaded');
  });
}

boot();
</script>
</body>
</html>
