<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DOIãƒªãƒ³ã‚¯é›†</title>
<style>
  :root{--gap:14px}
  body{font-family:system-ui,"Noto Sans JP",sans-serif;margin:24px}
  header{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin-bottom:var(--gap)}
  input,select,button{padding:.6rem .7rem;font-size:16px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:var(--gap)}
  .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px}
  .muted{color:#6b7280;font-size:0.9em}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .tag{background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:.1rem .6rem;font-size:.85em}
  a{color:#1f6feb;text-decoration:none}
  a:hover{text-decoration:underline}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:.3rem .6rem;display:inline-block}
  .right{margin-left:auto}
  .btn{cursor:pointer;background:#fff}
  .btn:disabled{opacity:.6;cursor:not-allowed}
</style>
</head>
<body>
<header>
  <input id="q" placeholder="ã‚¿ã‚¤ãƒˆãƒ« / è‘—è€… / é›‘èªŒ / DOI / ã‚¿ã‚°ã§æ¤œç´¢" oninput="render()" />
  <select id="sort" onchange="render()">
    <option value="year-desc">æ–°ã—ã„é †</option>
    <option value="year-asc">å¤ã„é †</option>
    <option value="title-asc">ã‚¿ã‚¤ãƒˆãƒ«Aâ†’Z</option>
    <option value="title-desc">ã‚¿ã‚¤ãƒˆãƒ«Zâ†’A</option>
  </select>
  <span id="count" class="pill"></span>
  <span class="right muted">æ›´æ–°ã¯ <code>dois.csv</code> ã‚’ç·¨é›†ã—ã¦ã‚³ãƒŸãƒƒãƒˆ</span>
</header>

<div id="list" class="grid">
  <div class="muted">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
</div>

<script>
/** â–¼ CSVã‚½ãƒ¼ã‚¹ï¼ˆåŒéšå±¤ã® dois.csv ã‚’æƒ³å®šï¼‰+ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚¹ã‚¿ãƒ¼ */
const DATA_SRC = (()=>{
  const u = new URL('dois.csv', location.href);
  u.searchParams.set('t', Date.now());   // GitHub Pages ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å›é¿
  return u.href;
})();

/** â–¼ Crossrefãƒ¡ã‚¿ã®ç°¡æ˜“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ */
async function fetchCrossref(doi){
  const key = 'cr_' + doi;
  const cached = localStorage.getItem(key);
  if (cached) { try { return JSON.parse(cached); } catch(e){} }
  const url = 'https://api.crossref.org/works/' + encodeURIComponent(doi);
  const res = await fetch(url, {headers: {'Accept': 'application/json'}});
  if (!res.ok) throw new Error('Crossref error ' + res.status);
  const json = await res.json();
  localStorage.setItem(key, JSON.stringify(json));
  return json;
}

/** â–¼ CSVèª­ã¿è¾¼ã¿ï¼ˆBOMé™¤å»ãƒ»å¤§å°æ–‡å­—ç„¡è¦–ï¼‰ */
async function fetchCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error('CSV not found: ' + res.status);
  const text = await res.text();
  const lines = text.replace(/^\uFEFF/, '').trim().split(/\r?\n/); // BOMé™¤å»
  if (!lines.length) return [];
  const rawHeader = splitCsvLine(lines.shift()).map(s => s.replace(/^\uFEFF/, '').trim());
  const headerLower = rawHeader.map(h => h.toLowerCase());
  const idx = Object.fromEntries(headerLower.map((h,i)=>[h,i])); // å°æ–‡å­—â†’index

  return lines.map(line=>{
    const cells = splitCsvLine(line);
    return {
      doi:   cells[idx['doi']]   ?? '',
      tags:  cells[idx['tags']]  ?? '',
      notes: cells[idx['notes']] ?? ''
    };
  }).filter(r=>r.doi);
}

function splitCsvLine(line){
  // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆå¯¾å¿œã®ç°¡æ˜“CSV
  const re = /("([^"]|"")*"|[^,]+)/g;
  const out = [];
  let m;
  while ((m = re.exec(line)) !== null) out.push(m[0].replace(/^"(.*)"$/,'$1').replace(/""/g,'"'));
  return out.map(s=>s.trim());
}

/** â–¼ æ–‡å­—åˆ—æ•´å½¢ */
const norm = s => (s||'').toString().toLowerCase();
const escapeHtml = s => (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/** â–¼ è¡¨ç¤ºç”¨ã®å¤‰æ› */
function toCite(obj) {
  const m = obj?.message || {};
  const title = (m.title && m.title[0]) || '';
  const year  = (m.created?.['date-parts']?.[0]?.[0]) || (m.issued?.['date-parts']?.[0]?.[0]) || '';
  const auth  = (m.author||[]).map(a=>[a.given,a.family].filter(Boolean).join(' ')).join(', ');
  const journal = (m['container-title'] && m['container-title'][0]) || '';
  return { title, year, authors: auth, journal };
}

/** â–¼ ãƒ•ã‚£ãƒ«ã‚¿ï¼†ã‚½ãƒ¼ãƒˆ */
function passFilter(item, q){
  if (!q) return true;
  return [item.meta.title, item.meta.authors, item.meta.journal, item.doi, item.tags, item.notes]
    .some(v => norm(v).includes(q));
}
function sortBy(items, mode){
  const byYear = (a,b)=> (b.meta.year||0)-(a.meta.year||0);
  const byTitle = (a,b)=> (a.meta.title||'').localeCompare(b.meta.title||'');
  if (mode==='year-asc') return items.sort((a,b)=>-byYear(a,b));
  if (mode==='title-asc') return items.sort(byTitle);
  if (mode==='title-desc') return items.sort((a,b)=>-byTitle(a,b));
  return items.sort(byYear);
}

/** â–¼ ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ */
let records = []; // {doi,tags,notes,meta}

/** â–¼ èµ·å‹•å‡¦ç† */
async function boot(){
  try{
    const rows = await fetchCsv(DATA_SRC);
    records = await Promise.all(rows.map(async r=>{
      try{
        const cr = await fetchCrossref(r.doi);
        const cite = toCite(cr);
        return { doi:r.doi, tags:r.tags||'', notes:r.notes||'', meta:cite };
      }catch(e){
        return { doi:r.doi, tags:r.tags||'', notes:r.notes||'', meta:{title:'(å–å¾—å¤±æ•—)', authors:'', journal:'', year:''}};
      }
    }));
    render();
  }catch(err){
    console.error(err);
    document.getElementById('list').innerHTML =
      `<div class="muted">èª­è¾¼ã‚¨ãƒ©ãƒ¼: ${escapeHtml(String(err))}</div>`;
  }
}

/** â–¼ æç”» */
function render(){
  const q = norm(document.getElementById('q').value);
  const mode = document.getElementById('sort').value;
  const target = document.getElementById('list');
  const arr = sortBy(records.filter(r=>passFilter(r,q)), mode);

  target.innerHTML = arr.map(r=>{
    const doiUrl = 'https://doi.org/' + encodeURIComponent(r.doi);
    const year = r.meta.year ? ` (${r.meta.year})` : '';
    const tags = (r.tags||'').split(';').map(s=>s.trim()).filter(Boolean).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join(' ');
    const notes = r.notes ? `<div class="muted">ğŸ“ ${escapeHtml(r.notes)}</div>`:'';
    const journal = r.meta.journal ? `<span class="muted"> â€” ${escapeHtml(r.meta.journal)}</span>` : '';
    const title = escapeHtml(r.meta.title || r.doi);
    const authors = escapeHtml(r.meta.authors || '');
    const doiEnc = encodeURIComponent(r.doi);

    return `
      <div class="card">
        <div><a href="${doiUrl}" target="_blank" rel="noopener"><strong>${title}</strong></a>${year}${journal}</div>
        <div class="muted">${authors}</div>
        <div class="row" style="margin:.4rem 0">${tags}</div>
        ${notes}
        <div class="row" style="margin-top:.6rem">
          <button class="pill btn" onclick="downloadBibtexUTF8('${doiEnc}')">BibTeXï¼ˆCrossref/UTF-8ä¿å­˜ï¼‰</button>
          <code class="pill">${escapeHtml(r.doi)}</code>
        </div>
      </div>`;
  }).join('');

  document.getElementById('count').textContent = `${arr.length} ä»¶`;
}

/** â–¼ æ–‡å­—åŒ–ã‘å¯¾ç­–ï¼šCrossrefåŸæœ¬ã‚’å–å¾—ã—ã€UTF-8æ˜ç¤ºã§ä¿å­˜ */
async function downloadBibtexUTF8(doiEnc){
  const doi = decodeURIComponent(doiEnc);
  const url = 'https://api.crossref.org/works/' + encodeURIComponent(doi) + '/transform/application/x-bibtex';
  const res = await fetch(url, { headers: { 'Accept': 'application/x-bibtex' }, cache:'no-store' });
  if(!res.ok) { alert('Crossrefå–å¾—ã‚¨ãƒ©ãƒ¼: ' + res.status); return; }
  const text = await res.text();
  // BOMã‚’ä»˜ä¸ã—UTF-8ã§ä¿å­˜ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰èª¤åˆ¤å®šã‚’å›é¿ï¼‰
  const blob = new Blob(["\uFEFF" + text], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (doi.replace(/[^\w.-]+/g,'_')) + '.bib';
  document.body.appendChild(a);
  a.click();
  a.remove();
}

boot();
</script>
</body>
</html>
