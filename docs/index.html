<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DOIリンク集</title>
<style>
  :root{--gap:14px}
  body{font-family:system-ui,"Noto Sans JP",sans-serif;margin:24px}
  header{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin-bottom:var(--gap)}
  input,select,button{padding:.6rem .7rem;font-size:16px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:var(--gap)}
  .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px}
  .muted{color:#6b7280;font-size:0.9em}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .tag{background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:.1rem .6rem;font-size:.85em}
  a{color:#1f6feb;text-decoration:none}
  a:hover{text-decoration:underline}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:.3rem .6rem;display:inline-block}
  .right{margin-left:auto}
  .btn{cursor:pointer;background:#fff}
  .btn:disabled{opacity:.6;cursor:not-allowed}
</style>
</head>
<body>
<header>
  <input id="q" placeholder="タイトル / 著者 / 雑誌 / DOI / タグで検索" oninput="render()" />
  <select id="sort" onchange="render()">
    <option value="year-desc">新しい順</option>
    <option value="year-asc">古い順</option>
    <option value="title-asc">タイトルA→Z</option>
    <option value="title-desc">タイトルZ→A</option>
  </select>
  <span id="count" class="pill"></span>
  <span class="right muted">更新は <code>dois.csv</code> を編集してコミット</span>
</header>

<div id="list" class="grid">
  <div class="muted">読み込み中…</div>
</div>

<script>
/** ▼ CSVソース（同階層の dois.csv を想定）+ キャッシュバスター */
const DATA_SRC = (() => {
  const u = new URL('dois.csv', location.href);
  u.searchParams.set('t', Date.now());   // GitHub Pages のキャッシュを回避
  return u.href;
})();

/** ▼ 文字列ユーティリティ */
const norm = s => (s||'').toString().toLowerCase();
const escapeHtml = s => (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/** ▼ CSV読み込み（BOM除去・大小文字無視） */
async function fetchCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error('CSV not found: ' + res.status);
  const text = await res.text();
  const lines = text.replace(/^\uFEFF/, '').trim().split(/\r?\n/); // BOM除去
  if (!lines.length) return [];
  const rawHeader = splitCsvLine(lines.shift()).map(s => s.replace(/^\uFEFF/, '').trim());
  const headerLower = rawHeader.map(h => h.toLowerCase());
  const idx = Object.fromEntries(headerLower.map((h,i)=>[h,i])); // 小文字→index

  return lines.filter(Boolean).map(line=>{
    const cells = splitCsvLine(line);
    return {
      doi:   (cells[idx['doi']]   ?? '').trim(),
      tags:  (cells[idx['tags']]  ?? '').trim(),
      notes: (cells[idx['notes']] ?? '').trim()
    };
  }).filter(r=>r.doi);
}
function splitCsvLine(line){
  // ダブルクォート対応の簡易CSV
  const re = /("([^"]|"")*"|[^,]+)/g;
  const out = [];
  let m;
  while ((m = re.exec(line)) !== null) out.push(m[0].replace(/^"(.*)"$/,'$1').replace(/""/g,'"'));
  return out.map(s=>s.trim());
}

/** ▼ メタデータ取得（Crossref → doi.org/CSL → DataCite の順でフェイルオーバー）+ ローカルキャッシュ */
async function fetchMeta(doi){
  const key = 'meta_' + doi;
  const cached = localStorage.getItem(key);
  if (cached) { try { return JSON.parse(cached); } catch(e){} }

  // 1) Crossref
  try {
    const r = await fetch('https://api.crossref.org/works/' + encodeURIComponent(doi), {
      headers: {'Accept': 'application/json'}
    });
    if (r.ok) {
      const json = await r.json();
      const out = { source: 'crossref', raw: json };
      localStorage.setItem(key, JSON.stringify(out));
      return out;
    }
  } catch {}

  // 2) doi.org (CSL-JSON)
  try {
    const r = await fetch('https://doi.org/' + encodeURIComponent(doi), {
      headers: {'Accept': 'application/vnd.citationstyles.csl+json'}
    });
    if (r.ok) {
      const json = await r.json();
      const out = { source: 'doi.org', raw: json };
      localStorage.setItem(key, JSON.stringify(out));
      return out;
    }
  } catch {}

  // 3) DataCite
  try {
    const r = await fetch('https://api.datacite.org/dois/' + encodeURIComponent(doi), {
      headers: {'Accept': 'application/json'}
    });
    if (r.ok) {
      const json = await r.json();
      const out = { source: 'datacite', raw: json };
      localStorage.setItem(key, JSON.stringify(out));
      return out;
    }
  } catch {}

  const out = { source: 'none', raw: null };
  localStorage.setItem(key, JSON.stringify(out));
  return out;
}

/** ▼ 取得ソース別に統一フォーマットへ整形 */
function toCite(meta){
  const { source, raw } = meta || {};
  if (!raw) return { title: '(取得失敗)', year: '', authors: '', journal: '' };

  if (source === 'crossref') {
    const m = raw.message || {};
    return {
      title: (m.title && m.title[0]) || '',
      year:  (m.created?.['date-parts']?.[0]?.[0]) || (m.issued?.['date-parts']?.[0]?.[0]) || '',
      authors: (m.author||[]).map(a=>[a.given,a.family].filter(Boolean).join(' ')).join(', '),
      journal: (m['container-title'] && m['container-title'][0]) || ''
    };
  }

  if (source === 'doi.org') { // CSL-JSON
    const m = raw || {};
    const year = (m.issued?.['date-parts']?.[0]?.[0]) || '';
    const authors = (m.author||[]).map(a=>{
      if (a.family || a.given) return [a.given, a.family].filter(Boolean).join(' ');
      return a.name || ''; // 組織名など
    }).join(', ');
    return {
      title: Array.isArray(m.title) ? m.title[0] : (m.title || ''),
      year,
      authors,
      journal: Array.isArray(m['container-title']) ? m['container-title'][0] : (m['container-title'] || '')
    };
  }

  if (source === 'datacite') {
    const a = raw.data?.attributes || {};
    const year = a.publicationYear || '';
    const authors = (a.creators||a.contributors||[]).map(p=>{
      return [p.givenName, p.familyName, p.name].filter(Boolean)[0] || '';
    }).filter(Boolean).join(', ');
    const title = (a.titles && a.titles[0]?.title) || '';
    const journal = (a.container && a.container['title']) || (a.publisher || '');
    return { title, year, authors, journal };
  }

  return { title: '(取得失敗)', year: '', authors: '', journal: '' };
}

/** ▼ フィルタ＆ソート */
function passFilter(item, q){
  if (!q) return true;
  return [item.meta.title, item.meta.authors, item.meta.journal, item.doi, item.tags, item.notes]
    .some(v => norm(v).includes(q));
}
function sortBy(items, mode){
  const byYear = (a,b)=> (b.meta.year||0)-(a.meta.year||0);
  const byTitle = (a,b)=> (a.meta.title||'').localeCompare(b.meta.title||'');
  if (mode==='year-asc') return items.sort((a,b)=>-byYear(a,b));
  if (mode==='title-asc') return items.sort(byTitle);
  if (mode==='title-desc') return items.sort((a,b)=>-byTitle(a,b));
  return items.sort(byYear);
}

/** ▼ グローバル状態 */
let records = []; // {doi,tags,notes,meta,source}

/** ▼ 起動処理 */
async function boot(){
  try{
    const rows = await fetchCsv(DATA_SRC);
    records = await Promise.all(rows.map(async r=>{
      const meta = await fetchMeta(r.doi);
      const cite = toCite(meta);
      return { doi:r.doi, tags:r.tags||'', notes:r.notes||'', meta:cite, source:meta.source };
    }));
    render();
  }catch(err){
    console.error(err);
    document.getElementById('list').innerHTML =
      `<div class="muted">読込エラー: ${escapeHtml(String(err))}</div>`;
  }
}

/** ▼ 描画 */
function render(){
  const q = norm(document.getElementById('q').value);
  const mode = document.getElementById('sort').value;
  const target = document.getElementById('list');
  const arr = sortBy(records.filter(r=>passFilter(r,q)), mode);

  target.innerHTML = arr.map(r=>{
    const doiUrl = 'https://doi.org/' + encodeURIComponent(r.doi);
    const year = r.meta.year ? ` (${r.meta.year})` : '';
    const tags = (r.tags||'').split(';').map(s=>s.trim()).filter(Boolean).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join(' ');
    const notes = r.notes ? `<div class="muted">📝 ${escapeHtml(r.notes)}</div>`:'';
    const journal = r.meta.journal ? `<span class="muted"> — ${escapeHtml(r.meta.journal)}</span>` : '';
    const title = escapeHtml(r.meta.title || r.doi);
    const authors = escapeHtml(r.meta.authors || '');
    const doiEnc = encodeURIComponent(r.doi);

    return `
      <div class="card">
        <div><a href="${doiUrl}" target="_blank" rel="noopener"><strong>${title}</strong></a>${year}${journal}</div>
        <div class="muted">${authors}</div>
        <div class="row" style="margin:.4rem 0">${tags}</div>
        ${notes}
        <div class="row" style="margin-top:.6rem">
          <button class="pill btn" onclick="downloadBibtexUTF8('${doiEnc}')">BibTeX（UTF-8保存）</button>
          <code class="pill" title="source: ${r.source||'unknown'}">${escapeHtml(r.doi)}</code>
        </div>
      </div>`;
  }).join('');

  document.getElementById('count').textContent = `${arr.length} 件`;
}

/** ▼ BibTeX取得（Crossref → CrossCite → doi.org の順でフォールバック）+ UTF-8保存 */
async function downloadBibtexUTF8(doiEnc){
  const doi = decodeURIComponent(doiEnc);
  const tryUrls = [
    'https://api.crossref.org/works/' + encodeURIComponent(doi) + '/transform/application/x-bibtex',
    'https://citation.crosscite.org/format?doi=' + encodeURIComponent(doi) + '&style=bibtex',
    'https://doi.org/' + encodeURIComponent(doi) // AcceptヘッダでBibTeX要求
  ];

  let text = null;
  for (const u of tryUrls) {
    try {
      const headers = u.includes('doi.org')
        ? { 'Accept': 'application/x-bibtex' }
        : { 'Accept': 'text/plain' };
      const res = await fetch(u, { headers, cache:'no-store' });
      if (res.ok) { text = await res.text(); break; }
    } catch {}
  }

  if (!text) { alert('BibTeXの取得に失敗しました'); return; }

  // UTF-8 + BOM で保存（ブラウザの文字コード誤判定を回避）
  const blob = new Blob(["\uFEFF" + text], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (doi.replace(/[^\w.-]+/g,'_')) + '.bib';
  document.body.appendChild(a);
  a.click();
  a.remove();
}

boot();
</script>
</body>
</html>
