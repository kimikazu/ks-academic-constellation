<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DOIリンク集</title>
<style>
  :root{--gap:14px}
  body{font-family:system-ui,"Noto Sans JP",sans-serif;margin:24px}
  header{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin-bottom:var(--gap)}
  input,select,button{padding:.6rem .7rem;font-size:16px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:var(--gap)}
  .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px}
  .muted{color:#6b7280;font-size:0.9em}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .tag{background:#eef2ff;border:1px solid #e0e7ff;border-radius:999px;padding:.1rem .6rem;font-size:.85em}
  a{color:#1f6feb;text-decoration:none}
  a:hover{text-decoration:underline}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:.3rem .6rem;display:inline-block}
  .right{margin-left:auto}
  .btn{cursor:pointer;background:#fff}
  .btn:disabled{opacity:.6;cursor:not-allowed}
</style>
</head>
<body>
<header>
  <input id="q" placeholder="タイトル / 著者 / 雑誌 / DOI / タグで検索" oninput="render()" />
  <select id="sort" onchange="render()">
    <option value="year-desc">新しい順</option>
    <option value="year-asc">古い順</option>
    <option value="title-asc">タイトルA→Z</option>
    <option value="title-desc">タイトルZ→A</option>
  </select>
  <span id="count" class="pill"></span>
  <span class="right muted">更新は <code>dois.csv</code> を編集してコミット</span>
</header>

<div id="list" class="grid">
  <div class="muted">読み込み中…</div>
</div>

<script>
/** ▼ CSVソース（同階層の dois.csv を想定）+ キャッシュバスター */
const DATA_SRC = (()=>{
  const u = new URL('dois.csv', location.href);
  u.searchParams.set('t', Date.now());   // GitHub Pages のキャッシュを回避
  return u.href;
})();

/** ▼ Crossrefメタの簡易キャッシュ */
async function fetchCrossref(doi){
  const key = 'cr_' + doi;
  const cached = localStorage.getItem(key);
  if (cached) { try { return JSON.parse(cached); } catch(e){} }
  const url = 'https://api.crossref.org/works/' + encodeURIComponent(doi);
  const res = await fetch(url, {headers: {'Accept': 'application/json'}});
  if (!res.ok) throw new Error('Crossref error ' + res.status);
  const json = await res.json();
  localStorage.setItem(key, JSON.stringify(json));
  return json;
}

/** ▼ CSV読み込み（BOM除去・大小文字無視） */
async function fetchCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error('CSV not found: ' + res.status);
  const text = await res.text();
  const lines = text.replace(/^\uFEFF/, '').trim().split(/\r?\n/); // BOM除去
  if (!lines.length) return [];
  const rawHeader = splitCsvLine(lines.shift()).map(s => s.replace(/^\uFEFF/, '').trim());
  const headerLower = rawHeader.map(h => h.toLowerCase());
  const idx = Object.fromEntries(headerLower.map((h,i)=>[h,i])); // 小文字→index

  return lines.map(line=>{
    const cells = splitCsvLine(line);
    return {
      doi:   cells[idx['doi']]   ?? '',
      tags:  cells[idx['tags']]  ?? '',
      notes: cells[idx['notes']] ?? ''
    };
  }).filter(r=>r.doi);
}

function splitCsvLine(line){
  // ダブルクォート対応の簡易CSV
  const re = /("([^"]|"")*"|[^,]+)/g;
  const out = [];
  let m;
  while ((m = re.exec(line)) !== null) out.push(m[0].replace(/^"(.*)"$/,'$1').replace(/""/g,'"'));
  return out.map(s=>s.trim());
}

/** ▼ 文字列整形 */
const norm = s => (s||'').toString().toLowerCase();
const escapeHtml = s => (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/** ▼ 表示用の変換 */
function toCite(obj) {
  const m = obj?.message || {};
  const title = (m.title && m.title[0]) || '';
  const year  = (m.created?.['date-parts']?.[0]?.[0]) || (m.issued?.['date-parts']?.[0]?.[0]) || '';
  const auth  = (m.author||[]).map(a=>[a.given,a.family].filter(Boolean).join(' ')).join(', ');
  const journal = (m['container-title'] && m['container-title'][0]) || '';
  return { title, year, authors: auth, journal };
}

/** ▼ フィルタ＆ソート */
function passFilter(item, q){
  if (!q) return true;
  return [item.meta.title, item.meta.authors, item.meta.journal, item.doi, item.tags, item.notes]
    .some(v => norm(v).includes(q));
}
function sortBy(items, mode){
  const byYear = (a,b)=> (b.meta.year||0)-(a.meta.year||0);
  const byTitle = (a,b)=> (a.meta.title||'').localeCompare(b.meta.title||'');
  if (mode==='year-asc') return items.sort((a,b)=>-byYear(a,b));
  if (mode==='title-asc') return items.sort(byTitle);
  if (mode==='title-desc') return items.sort((a,b)=>-byTitle(a,b));
  return items.sort(byYear);
}

/** ▼ グローバル状態 */
let records = []; // {doi,tags,notes,meta}

/** ▼ 起動処理 */
async function boot(){
  try{
    const rows = await fetchCsv(DATA_SRC);
    records = await Promise.all(rows.map(async r=>{
      try{
        const cr = await fetchCrossref(r.doi);
        const cite = toCite(cr);
        return { doi:r.doi, tags:r.tags||'', notes:r.notes||'', meta:cite };
      }catch(e){
        return { doi:r.doi, tags:r.tags||'', notes:r.notes||'', meta:{title:'(取得失敗)', authors:'', journal:'', year:''}};
      }
    }));
    render();
  }catch(err){
    console.error(err);
    document.getElementById('list').innerHTML =
      `<div class="muted">読込エラー: ${escapeHtml(String(err))}</div>`;
  }
}

/** ▼ 描画 */
function render(){
  const q = norm(document.getElementById('q').value);
  const mode = document.getElementById('sort').value;
  const target = document.getElementById('list');
  const arr = sortBy(records.filter(r=>passFilter(r,q)), mode);

  target.innerHTML = arr.map(r=>{
    const doiUrl = 'https://doi.org/' + encodeURIComponent(r.doi);
    const year = r.meta.year ? ` (${r.meta.year})` : '';
    const tags = (r.tags||'').split(';').map(s=>s.trim()).filter(Boolean).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join(' ');
    const notes = r.notes ? `<div class="muted">📝 ${escapeHtml(r.notes)}</div>`:'';
    const journal = r.meta.journal ? `<span class="muted"> — ${escapeHtml(r.meta.journal)}</span>` : '';
    const title = escapeHtml(r.meta.title || r.doi);
    const authors = escapeHtml(r.meta.authors || '');
    const doiEnc = encodeURIComponent(r.doi);

    return `
      <div class="card">
        <div><a href="${doiUrl}" target="_blank" rel="noopener"><strong>${title}</strong></a>${year}${journal}</div>
        <div class="muted">${authors}</div>
        <div class="row" style="margin:.4rem 0">${tags}</div>
        ${notes}
        <div class="row" style="margin-top:.6rem">
          <button class="pill btn" onclick="downloadBibtexUTF8('${doiEnc}')">BibTeX（Crossref/UTF-8保存）</button>
          <code class="pill">${escapeHtml(r.doi)}</code>
        </div>
      </div>`;
  }).join('');

  document.getElementById('count').textContent = `${arr.length} 件`;
}

/** ▼ 文字化け対策：Crossref原本を取得し、UTF-8明示で保存 */
async function downloadBibtexUTF8(doiEnc){
  const doi = decodeURIComponent(doiEnc);
  const url = 'https://api.crossref.org/works/' + encodeURIComponent(doi) + '/transform/application/x-bibtex';
  const res = await fetch(url, { headers: { 'Accept': 'application/x-bibtex' }, cache:'no-store' });
  if(!res.ok) { alert('Crossref取得エラー: ' + res.status); return; }
  const text = await res.text();
  // BOMを付与しUTF-8で保存（ブラウザの文字コード誤判定を回避）
  const blob = new Blob(["\uFEFF" + text], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (doi.replace(/[^\w.-]+/g,'_')) + '.bib';
  document.body.appendChild(a);
  a.click();
  a.remove();
}

boot();
</script>
</body>
</html>
